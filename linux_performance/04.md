## 经常说的 CPU 上下文切换是什么意思（下）

### 怎么查看系统的上下文切换情况

vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。

实例：

```
# 每隔5秒输出1组数据
$ vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 7005360  91564 818900    0    0     0     0   25   33  0  0 100  0  0
```

- cs（context switch）是每秒上下文切换的次数。
- in（interrupt）则是每秒中断的次数。
- r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。
- b（Blocked）则是处于[不可中断](./02.md#Blocked)睡眠状态的进程数。

vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用我们前面提到过的 pidstat 了。给它加上 -w 选项，你就可以查看每个进程上下文切换的情况了。

```
# 每隔5秒输出1组数据
$ pidstat -w 5
Linux 4.15.0 (ubuntu)  09/23/18  _x86_64_  (2 CPU)

08:18:26      UID       PID   cswch/s nvcswch/s  Command
08:18:31        0         1      0.20      0.00  systemd
08:18:31        0         8      5.40      0.00  rcu_sched
```

重点关注对象：一个是 cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数，另一个则是 nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。

- **自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换**。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。
- **非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换**。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。

### 案例分析

- 准备：2 CPU，8GB 内存机器；预先安装 sysbench 和 sysstat 包，如 apt install sysbench sysstat；
- 操作和分析

  终端 1 运行 sysbench ，模拟系统多线程调度的瓶颈：

  ```
  # 以10个线程运行5分钟的基准测试，模拟多线程切换的问题
  $ sysbench --threads=10 --max-time=300 threads run
  ```

  终端 2 运行 vmstat ，观察上下文切换情况：

  ```
  # 每隔1秒输出1组数据（需要Ctrl+C才结束）
  $ vmstat 1
  procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
   r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
   6  0      0 6487428 118240 1292772    0    0     0     0 9019 1398830 16 84  0  0  0
   8  0      0 6487428 118240 1292772    0    0     0     0 10191 1392312 16 84  0  0  0
  ```

  1. r 列：就绪队列的长度已经到了 8，远远超过了系统 CPU 的个数 2，所以肯定会有大量的 CPU 竞争。
  2. us（user）和 sy（system）列：这两列的 CPU 使用率加起来上升到了 100%，其中系统 CPU 使用率，也就是 sy 列高达 84%，说明 CPU 主要是被内核占用了。
  3. in 列：中断次数也上升到了 1 万左右，说明中断处理也是个潜在的问题。

  综合这几个指标，我们可以知道，系统的就绪队列过长，也就是正在运行和等待 CPU 的进程数过多，导致了大量的上下文切换，而上下文切换又导致了系统 CPU 的占用率升高。

  终端 3 用 pidstat 来看一下， CPU 和进程上下文切换的情况：

  ```
  # 每隔1秒输出1组数据（需要 Ctrl+C 才结束）
  # -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标
  $ pidstat -w -u 1
  08:06:33      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
  08:06:34        0     10488   30.00  100.00    0.00    0.00  100.00     0  sysbench
  08:06:34        0     26326    0.00    1.00    0.00    0.00    1.00     0  kworker/u4:2

  08:06:33      UID       PID   cswch/s nvcswch/s  Command
  08:06:34        0         8     11.00      0.00  rcu_sched
  08:06:34        0        16      1.00      0.00  ksoftirqd/1
  08:06:34        0       471      1.00      0.00  hv_balloon
  08:06:34        0      1230      1.00      0.00  iscsid
  08:06:34        0      4089      1.00      0.00  kworker/1:5
  08:06:34        0      4333      1.00      0.00  kworker/0:3
  08:06:34        0     10499      1.00    224.00  pidstat
  08:06:34        0     26326    236.00      0.00  kworker/u4:2
  08:06:34     1000     26784    223.00      0.00  sshd
  ```

  从 pidstat 的输出你可以发现，CPU 使用率的升高果然是 sysbench 导致的，它的 CPU 使用率已经达到了 100%。但上下文切换则是来自其他进程，包括非自愿上下文切换频率最高的 pidstat ，以及自愿上下文切换频率最高的内核线程 kworker 和 sshd。

  pidstat 输出的上下文切换次数，加起来也就几百，比 vmstat 的 139 万明显小了太多。这事因为 Linux 调度的基本单位实际上是线程，而我们的场景 sysbench 模拟的也是线程的调度问题，而 pidstat 加上 -t 参数后，才会输出线程的指标。

  在终端 3 再加上 -t 参数试一下：

  ```
  # 每隔1秒输出一组数据（需要 Ctrl+C 才结束）
  # -wt 参数表示输出线程的上下文切换指标
  $ pidstat -wt 1
  08:14:05      UID      TGID       TID   cswch/s nvcswch/s  Command
  ...
  08:14:05        0     10551         -      6.00      0.00  sysbench
  08:14:05        0         -     10551      6.00      0.00  |__sysbench
  08:14:05        0         -     10552  18911.00 103740.00  |__sysbench
  08:14:05        0         -     10553  18915.00 100955.00  |__sysbench
  08:14:05        0         -     10554  18827.00 103954.00  |__sysbench
  ```

  虽然 sysbench 进程（也就是主线程）的上下文切换次数看起来并不多，但它的子线程的上下文切换次数却有很多。看来，上下文切换罪魁祸首，还是过多的 sysbench 线程。

  开始排查中断次数过高的原因：

  从 /proc/interrupts 这个只读文件中可以读取中断信息。/proc 实际上是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。/proc/interrupts 就是这种通信机制的一部分，提供了一个只读的中断使用情况。

  终端 3 中执行：

  ```
  # -d 参数表示高亮显示变化的区域，如果第一屏看不到Rescheduling可以滚动屏幕
  $ watch -d cat /proc/interrupts
             CPU0       CPU1
  ...
  RES:    2450431    5279697   Rescheduling interrupts
  ...
  ```

  观察一段时间，可以发现，变化速度最快的是重调度中断（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断（Inter-Processor Interrupts，IPI，待补充扩展阅读资料）。

### 判断上下文切换是否正常的标准

上下文切换次数是否正常其实取决于系统本身的 CPU 性能。如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。

这时，你还需要根据上下文切换的类型，再做具体分析。比方说：

- 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；
- 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；
- 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。
