## 到底应该怎么理解“平均负载”？

### uptime 命令解析

```
$ uptime
 09:31:26 up 154 days, 22:23,  1 user,  load average: 2.38, 2.61, 2.74
```

```
 09:31:26                           //当前时间
 up 154 days, 22:23                 //系统运行时间
 1 user                             //正在登录用户数（同一用户多终端登录算做多用户）
 load average: 2.38, 2.61, 2.74     //过去1分钟、5分钟、15分钟的平均负载
```

详细解释可以执行命令：`$ man uptime`

### 平均负载定义

单位时间内，系统处于**可运行状态**和**不可中断状态**的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。

- **`可运行状态进程`**：正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。

<a id="Blocked"></a>

- **`不可中断状态进程`**：正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程（扩展阅读：[Linux 进程状态解析之 R、S、D、T、Z、X](https://yq.aliyun.com/articles/582869)、[Linux 中 D 状态的进程与平均负载](https://mp.weixin.qq.com/s/E5X9U7QIGnLCd4ETn2Ldlw)）。

  比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。**`不可中断状态实际上是系统对进程和硬件设备的一种保护机制`**。

- 状态分析

  最理想状态为每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。当平均负载为 2 时，意味着：

  1. 在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。
  2. 在 4 个 CPU 的系统上，意味着 CPU 有 50%的空闲。
  3. 而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。

### 平均负载多少时合理

- 查看系统有几个 CPU（这里指的是`逻辑核数`，扩展阅读：[ CPU 核心数与线程数](https://zhuanlan.zhihu.com/p/86855590)）
- 分析系统负载趋势的数据来源
- 当平均负载高于 CPU 数量 70%的时候，就应该分析排查负载高的问题了。但 70%这个数字并不是绝对的，最推荐的方法，还是把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势。

### 平均负载与 CPU 使用率

处于可运行状态和不可中断状态的进程数不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。

- CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；
- I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；
- 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。

### 案例分析

准备内容：

- 机器配置：2 CPU，8GB 内存 Ubuntu 18.04/其他 Linux 系统
- 工具： stress 和 sysstat 包，如`apt install stress sysstat`

  stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。

  sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。我们的案例会用到这个包的两个命令 mpstat 和 pidstat。

  1. mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。
  2. pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。

- 场景一：CPU 密集型进程

```
# 终端1
$ stress --cpu 1 --timeout 600

# 终端2
# -d 参数表示高亮显示变化的区域
$ watch -d uptime

# 终端3
# -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据
# 1 表示输出一次，如果想持续监控一段时间需要调大数字
$ mpstat -P ALL 5 1

# 查找需要优化的进程
# 间隔5秒后输出一组数据
$ pidstat -u 5 1
```

- 场景二：I/O 密集型进程

```
# 终端1
$ stress --i 1 --timeout 600

# 终端2
$ watch -d uptime

# 终端3
# -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据
# iowait无法升高的问题，是因为案例中stress使用的是 sync() 系统调用，它的作用是刷新缓冲区内存到磁盘中。对于新安装的虚拟机，缓冲区可能比较小，无法产生大的 i/o 压力，这样大部分就都是系统调用的消耗了。所以，你会看到只有系统CPU使用率升高。解决方法是使用stress的下一代stress-ng，它支持更丰富的选项，比如 stress-ng -i 1 --hdd 1 --timeout 600（--hdd表示读写临时文件）
# CentOS 中默认的sysstat稍微有点老导致可能 pidstat 输出中没有 %wait，源码或者 RPM 升级到11.5.5版本以后就可以看到了。
$ mpstat -P ALL 5 1

# 查找需要优化的进程，可以直接查看进程 i/o 情况，使用：pidstat -d
$ pidstat -u 5 1
```

- 场景三：大量进程的场景

```
# 终端1
$ stress -c 8 --timeout 600

# 终端2
$ watch -d uptime

# 查找需要优化的进程
$ pidstat -u 5 1
```

**`注意：本节内容为了照顾新同学没有细分线程和进程而直接使用了进程，因为线程/协程才是操作系统的 CPU 调度操最小粒度`**

### 思考

当发现平均负载升高后，分析排查思路：

1. 通过`pidstat`查看进程情况，找到导致平均负载升高的进程
2. 通过`mpstat`查看导致平均负载升高的因素（I/O 压力导致还是 CPU 压力导致）
3. 根据导致平均负载升高的因素对相应进程进行处理或优化
